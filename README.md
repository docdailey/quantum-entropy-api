# Quantum Entropy API - True Random Numbers from Quantum Mechanics

> Generate cryptographically secure random numbers using real quantum entropy from quantum tunneling events

## 🌟 Overview

This API provides access to genuine quantum random numbers generated by a hardware quantum random number generator (QRNG). Unlike pseudo-random number generators that use deterministic algorithms, our entropy comes from fundamentally unpredictable quantum mechanical processes.

### Why Quantum Random?

- **True Randomness**: Based on quantum tunneling events, which are fundamentally unpredictable
- **High Performance**: Generate up to 4 Mbps of raw quantum entropy  
- **Cryptographically Secure**: Perfect for encryption keys, nonces, and security tokens
- **No Patterns**: Passes all statistical randomness tests (NIST, Diehard, etc.)
- **Hardware-Based**: Physical quantum processes, not software algorithms

## 🚀 Quick Start

### Free Beta API
```
https://quantum-server.docdailey.ai
```

### Premium Access
For production use with higher limits, authentication, and SLA:
- **Sign up at**: https://quantum.docdailey.ai
- **Plans from**: $10/month
- **Features**: Higher rate limits, streaming access, priority support

### Get Random Bytes
```bash
curl "https://quantum-server.docdailey.ai/api/v1/random/bytes?count=32"
```

Response:
```json
{
  "success": true,
  "data": {
    "bytes": "a3f2b8c9d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4a5b6c7d8e9f0a1",
    "count": 32,
    "format": "hex",
    "correction": "none"
  }
}
```

## 🔧 API Endpoints

### Random Data Generation

#### `GET /api/v1/random/bytes`
Generate quantum random bytes.

**Parameters:**
- `count` (integer, 1-65536): Number of bytes to generate
- `format` (string): Output format - `hex` (default), `base64`, or `raw`
- `correction` (string): Bias correction - `none` (default), `von_neumann`, `matrix`

**Example:**
```bash
# Get 16 bytes with von Neumann correction
curl "https://quantum-server.docdailey.ai/api/v1/random/bytes?count=16&correction=von_neumann"
```

#### `GET /api/v1/random/integers`
Generate quantum random integers.

**Parameters:**
- `min` (integer): Minimum value (inclusive)
- `max` (integer): Maximum value (inclusive)  
- `count` (integer, 1-1000): Number of integers to generate

**Example:**
```bash
# Roll 5 dice
curl "https://quantum-server.docdailey.ai/api/v1/random/integers?min=1&max=6&count=5"
```

### Cryptographic Functions

#### `GET /api/v1/crypto/password`
Generate a secure password using quantum entropy.

**Parameters:**
- `length` (integer, 8-128): Password length
- `uppercase` (boolean): Include uppercase letters
- `lowercase` (boolean): Include lowercase letters
- `digits` (boolean): Include numbers
- `symbols` (boolean): Include special characters

**Example:**
```bash
# Generate a 20-character password with symbols
curl "https://quantum-server.docdailey.ai/api/v1/crypto/password?length=20&symbols=true"
```

#### `GET /api/v1/crypto/key`
Generate cryptographic keys.

**Parameters:**
- `level` (integer): Security level in bits (128, 192, 256, 512)

**Example:**
```bash
# Generate a 256-bit key
curl "https://quantum-server.docdailey.ai/api/v1/crypto/key?level=256"
```

#### `GET /api/v1/crypto/uuid`
Generate a UUID v4 using quantum randomness.

**Example:**
```bash
curl "https://quantum-server.docdailey.ai/api/v1/crypto/uuid"
```

### Streaming Entropy

#### `GET /api/v1/stream/raw`
Stream continuous quantum entropy (use with caution!).

**Parameters:**
- `format` (string): Output format - `hex`, `base64`, `binary`
- `correction` (string): Bias correction method

**Example:**
```bash
# Stream raw entropy (Ctrl+C to stop)
curl -N "https://quantum-server.docdailey.ai/api/v1/stream/raw?format=hex"
```

## 💻 Code Examples

### Python
```python
import requests
import json

# Get random bytes
def get_quantum_bytes(count=32):
    response = requests.get(
        "https://quantum-server.docdailey.ai/api/v1/random/bytes",
        params={"count": count}
    )
    data = response.json()
    return data['data']['bytes']

# Generate quantum password
def generate_quantum_password(length=16):
    response = requests.get(
        "https://quantum-server.docdailey.ai/api/v1/crypto/password",
        params={"length": length, "symbols": True}
    )
    data = response.json()
    return data['data']['password']

# Get random integers for lottery
def quantum_lottery(min_val=1, max_val=49, count=6):
    response = requests.get(
        "https://quantum-server.docdailey.ai/api/v1/random/integers",
        params={"min": min_val, "max": max_val, "count": count}
    )
    data = response.json()
    return sorted(data['data'])

# Example usage
print(f"Random bytes: {get_quantum_bytes(16)}")
print(f"Secure password: {generate_quantum_password(20)}")
print(f"Lottery numbers: {quantum_lottery()}")
```

### JavaScript / Node.js
```javascript
const https = require('https');

// Get quantum random bytes
async function getQuantumBytes(count = 32) {
    const url = `https://quantum-server.docdailey.ai/api/v1/random/bytes?count=${count}`;
    
    return new Promise((resolve, reject) => {
        https.get(url, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                const result = JSON.parse(data);
                resolve(result.data.bytes);
            });
        }).on('error', reject);
    });
}

// Generate cryptographic key
async function generateQuantumKey(bits = 256) {
    const url = `https://quantum-server.docdailey.ai/api/v1/crypto/key?level=${bits}`;
    
    const response = await fetch(url);
    const data = await response.json();
    return data.data.key;
}

// Quantum coin flip
async function quantumCoinFlip() {
    const url = 'https://quantum-server.docdailey.ai/api/v1/random/integers?min=0&max=1&count=1';
    const response = await fetch(url);
    const data = await response.json();
    return data.data[0] === 1 ? 'heads' : 'tails';
}

// Example usage
(async () => {
    console.log('Random bytes:', await getQuantumBytes(16));
    console.log('Encryption key:', await generateQuantumKey(256));
    console.log('Coin flip:', await quantumCoinFlip());
})();
```

### Rust
```rust
use reqwest;
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize)]
struct ApiResponse<T> {
    success: bool,
    data: T,
}

#[derive(Debug, Deserialize)]
struct BytesData {
    bytes: String,
    count: u32,
    format: String,
}

#[derive(Debug, Deserialize)]
struct PasswordData {
    password: String,
    length: u32,
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Get quantum random bytes
    let bytes_response: ApiResponse<BytesData> = reqwest::get(
        "https://quantum-server.docdailey.ai/api/v1/random/bytes?count=32"
    )
    .await?
    .json()
    .await?;
    
    println!("Random bytes: {}", bytes_response.data.bytes);
    
    // Generate quantum password
    let password_response: ApiResponse<PasswordData> = reqwest::get(
        "https://quantum-server.docdailey.ai/api/v1/crypto/password?length=20&symbols=true"
    )
    .await?
    .json()
    .await?;
    
    println!("Secure password: {}", password_response.data.password);
    
    // Get random integers
    let integers_response: ApiResponse<Vec<i32>> = reqwest::get(
        "https://quantum-server.docdailey.ai/api/v1/random/integers?min=1&max=100&count=5"
    )
    .await?
    .json()
    .await?;
    
    println!("Random integers: {:?}", integers_response.data);
    
    Ok(())
}
```

## 🛠️ Sample Applications

### 1. Quantum Dice Roller
```python
#!/usr/bin/env python3
"""Quantum Dice - Roll dice using quantum randomness"""

import requests
import sys

def roll_quantum_dice(num_dice=2, sides=6):
    """Roll dice using quantum random numbers"""
    response = requests.get(
        "https://quantum-server.docdailey.ai/api/v1/random/integers",
        params={"min": 1, "max": sides, "count": num_dice}
    )
    
    if response.status_code == 200:
        data = response.json()
        rolls = data['data']
        print(f"🎲 Rolled {num_dice}d{sides}: {rolls}")
        print(f"   Total: {sum(rolls)}")
        return rolls
    else:
        print("Error getting quantum random numbers")
        return None

if __name__ == "__main__":
    if len(sys.argv) > 1:
        # Parse dice notation like "3d6" or "2d20"
        dice_notation = sys.argv[1]
        if 'd' in dice_notation:
            num, sides = dice_notation.split('d')
            roll_quantum_dice(int(num), int(sides))
        else:
            print("Usage: quantum_dice.py [NdS] (e.g., 3d6)")
    else:
        # Default: roll 2d6
        roll_quantum_dice()
```

### 2. Quantum Password Generator
```javascript
#!/usr/bin/env node
// quantum-pass.js - Generate secure passwords with quantum entropy

const https = require('https');

function generateQuantumPassword(length = 16, options = {}) {
    const params = new URLSearchParams({
        length: length,
        uppercase: options.uppercase !== false,
        lowercase: options.lowercase !== false,
        digits: options.digits !== false,
        symbols: options.symbols || false
    });
    
    const url = `https://quantum-server.docdailey.ai/api/v1/crypto/password?${params}`;
    
    return new Promise((resolve, reject) => {
        https.get(url, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                try {
                    const result = JSON.parse(data);
                    resolve(result.data.password);
                } catch (e) {
                    reject(e);
                }
            });
        }).on('error', reject);
    });
}

// CLI usage
async function main() {
    const args = process.argv.slice(2);
    const length = parseInt(args[0]) || 16;
    const includeSymbols = args.includes('--symbols');
    
    try {
        const password = await generateQuantumPassword(length, {
            symbols: includeSymbols
        });
        
        console.log(`\n🔐 Quantum Password (${length} chars):`);
        console.log(`   ${password}\n`);
        
        // Calculate entropy
        const charSet = 26 + 26 + 10 + (includeSymbols ? 32 : 0);
        const entropy = Math.log2(Math.pow(charSet, length));
        console.log(`   Entropy: ${entropy.toFixed(1)} bits`);
        
    } catch (error) {
        console.error('Error:', error.message);
    }
}

if (require.main === module) {
    main();
}
```

### 3. Quantum Lottery Number Picker
```python
#!/usr/bin/env python3
"""Quantum Lottery - Pick lottery numbers using quantum randomness"""

import requests
from datetime import datetime

def pick_lottery_numbers(total_numbers=6, max_number=49):
    """Pick unique lottery numbers using quantum randomness"""
    
    # Get more numbers than needed to handle duplicates
    response = requests.get(
        "https://quantum-server.docdailey.ai/api/v1/random/integers",
        params={"min": 1, "max": max_number, "count": total_numbers * 2}
    )
    
    if response.status_code == 200:
        data = response.json()
        numbers = data['data']
        
        # Get unique numbers
        unique_numbers = []
        for num in numbers:
            if num not in unique_numbers:
                unique_numbers.append(num)
            if len(unique_numbers) == total_numbers:
                break
        
        # Sort for display
        unique_numbers.sort()
        
        print(f"\n🎰 Quantum Lottery Numbers")
        print(f"   Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print(f"   Numbers: {' - '.join(map(str, unique_numbers))}")
        print(f"\n   Good luck! 🍀\n")
        
        return unique_numbers
    else:
        print("Error getting quantum random numbers")
        return None

def pick_powerball():
    """Pick Powerball numbers (5 regular + 1 powerball)"""
    print("\n⚡ Quantum Powerball Picker")
    
    # Get 5 regular numbers (1-69)
    regular = pick_lottery_numbers(5, 69)
    
    # Get powerball (1-26)
    response = requests.get(
        "https://quantum-server.docdailey.ai/api/v1/random/integers",
        params={"min": 1, "max": 26, "count": 1}
    )
    
    if response.status_code == 200 and regular:
        powerball = response.json()['data'][0]
        print(f"   Powerball: {powerball} 🔴\n")

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) > 1 and sys.argv[1] == "powerball":
        pick_powerball()
    else:
        pick_lottery_numbers()
```

## 🔬 Technical Details

### Hardware
Our quantum entropy is generated by a Quantis QRNG (Quantum Random Number Generator) that uses:
- Quantum tunneling effect in a semiconductor junction
- Operates at the quantum scale where nature is fundamentally random
- Generates raw entropy at 4 Mbps
- Passes all major randomness test suites

### Bias Correction Methods
- **None**: Raw quantum data (already very high quality)
- **Von Neumann**: Classic debiasing algorithm, reduces output by ~75%
- **Matrix**: Advanced extraction using linear algebra, ~50% output

### Performance
- Latency: <10ms for most requests
- Throughput: Up to 500KB/s per client
- Availability: 99.9% uptime target

## 📊 Statistics and Testing

The quantum entropy passes all major randomness tests:
- NIST Statistical Test Suite
- Diehard Battery of Tests
- TestU01 Crush
- ENT - Entropy Testing

Example entropy analysis:
```bash
# Test 1MB of quantum data
curl -s "https://quantum-server.docdailey.ai/api/v1/random/bytes?count=1048576&format=raw" | ent

# Results:
# Entropy = 7.999998 bits per byte
# Chi-square distribution: 247.25 (random > 10.83)
# Arithmetic mean: 127.4982 (127.5 = random)
# Monte Carlo π estimation: 3.14159892 (error 0.00%)
```

## 🌐 Use Cases

- **Cryptography**: Generate unbreakable encryption keys
- **Blockchain**: Seed wallets and generate nonces
- **Gaming**: Fair dice rolls and card shuffles
- **Simulations**: Monte Carlo and scientific modeling
- **Security**: Session tokens and password generation
- **Lottery**: Truly random number selection
- **Research**: Quantum mechanics experiments

## 📈 Rate Limits

### Free Beta API
- 60 requests per minute
- 10MB per day
- Maximum 64KB per request

### Premium Tiers
Available at https://quantum.docdailey.ai:
- **Developer** ($10/mo): 100MB/month, 60 req/min
- **Professional** ($50/mo): 1GB/month, 300 req/min, streaming access
- **Enterprise** ($500/mo): 50GB/month, unlimited requests, SLA

## 🔗 Links

- **Premium Access & Sign Up**: https://quantum.docdailey.ai
- **Free Beta API**: https://quantum-server.docdailey.ai
- **API Status**: https://status.quantum.docdailey.ai
- **GitHub**: https://github.com/docdailey/quantum-entropy-api

## 📄 License

This documentation and example code are released under the MIT License.

The quantum entropy API service is proprietary - see terms of service for usage rights.

---

*Built with ❤️ and quantum mechanics*